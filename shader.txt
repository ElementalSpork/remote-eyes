// Exact distortion parameters (a, b, c) are not known yet, these are just placeholers
float a = 0.20f;
float b = 0.00f;
float c = 0.00f;
float d = 1 - (a + b + c);
 
// Calculate the source location "radius" (distance from the centre of the viewport)
// fragPos - xy position of the current fragment (destination) in NDC space [-1 1]^2
float destR = length(fragPos);
float srcR = a * pow(destR,4) + b * pow(destR,3) + c * pow(destR,2) + d * destR;
 
// Calculate the source vector (radial)
vec2 correctedRadial = normalize(fragPos) * srcR;
 
// Transform the coordinates (from [-1,1]^2 to [0, 1]^2)
vec2 uv = (correctedRadial/2.0f) + vec2(0.5f);
 
// Sample the texture at the source location
fragColor = texture(tex, uv);  









#ifdef GL_ES
precision highp float;
#endif
varying vec3 vColor;
varying vec2 uv;

uniform sampler2D tex;

void main(void)
{
    vec4 color = gl_FragCoord;
    color.w = 1.0;
    color.x = color.x/200.0;
    color.y = color.y/200.0;
    color.z = color.z/200.0;
    gl_FragColor = texture2D(tex, vec2(color.x, color.y));
    // gl_FragColor = texture2D(tex,uv)*vec4(vColor, 1.0);
}
	


	attribute vec3 vertex;
attribute vec3 normal;
attribute vec2 uv1;

uniform mat4 _mvProj;
uniform mat3 _norm;
uniform float _time;

varying vec2 uv;
varying vec3 vColor;

#pragma include "light.glsl"

// constants
vec3 materialColor = vec3(1.0,0.7,0.8);
vec3 specularColor = vec3(1.0,1.0,1.0);

void main(void) {
	// compute position
	gl_Position = _mvProj * vec4(vertex, 1.0);

	uv = uv1;
	// compute light info
	vec3 n = normalize(_norm * normal);
	vec3 diffuse;
	float specular;
	float glowingSpecular = sin(_time*0.003)*20.0+20.0;
	getDirectionalLight(n, _dLight, glowingSpecular, diffuse, specular);
	vColor = max(diffuse,_ambient.xyz)*materialColor+specular*specularColor;
} 













#ifdef GL_ES
precision highp float;
#endif
varying vec3 vColor;
varying vec2 uv;

uniform sampler2D tex;

void main(void)
{
    float x;
    float y;
    x = uv.x;
    y = uv.y;
    x -= 0.5;
    y -= 0.5;
    
    if(x > 0.0 && y > 0.0) {
        gl_FragColor = texture2D(tex, vec2(x, y));
    }
    else {
        // red
        gl_FragColor = vec4(1.0,0.0,0.0,1.0);
    }
	// gl_FragColor = texture2D(tex,uv)*vec4(vColor, 1.0);
}



















#ifdef GL_ES
precision highp float;
#endif
varying vec3 vColor;
varying vec2 uv;

uniform sampler2D tex;

void main(void)
{
    float x;
    float y;
    
    float r;
    float phi;
    
    x = uv.x;
    y = uv.y;
    x -= 0.5;
    y -= 0.5;
    
    r = sqrt(x*x + y*y);
    phi = atan(y,x);
    
    r = r*r*1.0 + r*r*r*r*1.0 + r*r*r*r*r*r*1.0;
    r *= 1.6;
    
    x = r*cos(phi);
    y = r*sin(phi);
    
    x+=0.5;
    y+=0.5;
    
    if(x >= 0.0 && y >= 0.0 && x <= 1.0 && y <= 1.0) {
        gl_FragColor = texture2D(tex, vec2(x,y));
    }
    else {
        // red
        gl_FragColor = vec4(0.2,0.0,0.0,1.0);
    }
}